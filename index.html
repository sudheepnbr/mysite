<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OIH PDF Pro - Auto-Sync OCR</title>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
    
    <style>
        :root { --gold: #c9a035; --dark: #0d0d0d; }
        body { margin: 0; font-family: 'Segoe UI', sans-serif; background: #1a1a1a; color: white; overflow: hidden; }
        
        .toolbar { background: #000; padding: 12px; border-bottom: 2px solid var(--gold); display: flex; justify-content: center; gap: 10px; z-index: 100; position: relative; }
        .btn { padding: 10px 18px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; font-size: 13px; transition: 0.2s; }
        .btn-ocr { background: #4f46e5; color: white; }
        .btn-tool { background: var(--gold); color: black; }
        .btn-save { background: #10b981; color: white; box-shadow: 0 0 15px rgba(16,185,129,0.3); }

        #workspace { height: calc(100vh - 75px); overflow: auto; padding: 40px; background: #222; text-align: center; }
        #canvas-wrap { position: relative; display: inline-block; background: white; box-shadow: 0 0 50px rgba(0,0,0,0.6); }
        canvas { display: block; }

        /* OCR Editable Fields */
        .ocr-field { 
            position: absolute; color: transparent; background: rgba(79, 70, 229, 0.05); 
            border: 1px solid transparent; outline: none; white-space: nowrap; overflow: hidden;
        }
        .ocr-field:hover { background: rgba(79, 70, 229, 0.15); border-color: var(--gold); cursor: text; }
        /* When clicked/editing, make text visible and background white */
        .ocr-field:focus { color: black !important; background: white !important; border-color: var(--gold); z-index: 100; box-shadow: 0 0 10px rgba(0,0,0,0.2); }

        .loading-bar { display: none; position: fixed; top: 65px; left: 50%; transform: translateX(-50%); background: var(--gold); color: black; padding: 5px 20px; border-radius: 20px; font-weight: bold; font-size: 12px; z-index: 1000; }
        
        /* Clean Export Styles */
        .exporting .ocr-field { border: none !important; background: transparent !important; }
    </style>
</head>
<body>

<div id="loader" class="loading-bar">OCR Scanning... Please Wait...</div>

<div class="toolbar">
    <input type="file" id="pdf-input" accept="application/pdf" style="display:none">
    <button class="btn btn-tool" onclick="document.getElementById('pdf-input').click()">üìÇ Upload PDF</button>
    <button class="btn btn-ocr" onclick="startOCR()">üîç Scan & Edit Text</button>
    <button class="btn btn-tool" id="undoBtn" onclick="undo()" disabled>‚Ü©Ô∏è Undo</button>
    <button class="btn btn-save" onclick="savePdf()">üíæ DOWNLOAD EDITED PDF</button>
</div>

<div id="workspace">
    <div id="canvas-wrap">
        <canvas id="pdf-render"></canvas>
    </div>
</div>

<script>
    const { PDFDocument, rgb, StandardFonts } = PDFLib;
    let originalBytes = null;
    let history = [];
    let activeElements = [];

    // --- 1. FILE LOADER ---
    document.getElementById('pdf-input').onchange = async (e) => {
        const file = e.target.files[0];
        if(!file) return;
        originalBytes = await file.arrayBuffer();
        
        const loadingTask = pdfjsLib.getDocument({data: originalBytes});
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({scale: 1.5});
        
        const canvas = document.getElementById('pdf-render');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        await page.render({canvasContext: context, viewport: viewport}).promise;
        document.getElementById('canvas-wrap').style.width = canvas.width + 'px';
    };

    // --- 2. OCR "MAKE EDITABLE" LOGIC ---
    async function startOCR() {
        if(!originalBytes) return alert("Please upload a PDF first");
        document.getElementById('loader').style.display = 'block';

        const canvas = document.getElementById('pdf-render');
        const worker = await Tesseract.createWorker();
        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        
        const { data } = await worker.recognize(canvas);
        
        data.words.forEach(word => {
            const field = document.createElement('div');
            field.className = 'ocr-field';
            field.contentEditable = true;
            field.innerText = word.text;
            field.dataset.original = word.text; // Store original to track changes

            // Absolute Positioning
            field.style.left = word.bbox.x0 + 'px';
            field.style.top = word.bbox.y0 + 'px';
            field.style.width = (word.bbox.x1 - word.bbox.x0) + 'px';
            field.style.height = (word.bbox.y1 - word.bbox.y0) + 'px';
            field.style.fontSize = ((word.bbox.y1 - word.bbox.y0) * 0.8) + 'px';

            document.getElementById('canvas-wrap').appendChild(field);
            activeElements.push(field);
        });

        await worker.terminate();
        document.getElementById('loader').style.display = 'none';
        alert("OCR Ready! Click any text on the page to change it.");
    }

    // --- 3. AUTO-APPLY SAVE LOGIC ---
    async function savePdf() {
        if(!originalBytes) return;
        document.body.classList.add('exporting');

        try {
            const pdfDoc = await PDFDocument.load(originalBytes, { ignoreEncryption: true });
            const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
            const page = pdfDoc.getPages()[0];
            const { width, height } = page.getSize();
            const canvas = document.getElementById('pdf-render');
            
            const sx = width / canvas.width;
            const sy = height / canvas.height;

            activeElements.forEach(el => {
                // ONLY apply if the text was actually changed
                if (el.innerText !== el.dataset.original) {
                    const rect = el.getBoundingClientRect();
                    const canvRect = canvas.getBoundingClientRect();
                    
                    const x = (rect.left - canvRect.left) * sx;
                    const y = height - ((rect.top - canvRect.top) * sy) - (rect.height * sy);

                    // 1. Draw white box to "delete" the old text
                    page.drawRectangle({
                        x: x, y: y,
                        width: rect.width * sx,
                        height: rect.height * sy,
                        color: rgb(1, 1, 1)
                    });

                    // 2. Draw the NEW text in its place
                    page.drawText(el.innerText, {
                        x: x,
                        y: y + (2 * sy),
                        size: (rect.height * sy) * 0.8,
                        font: font,
                        color: rgb(0, 0, 0)
                    });
                }
            });

            const savedBytes = await pdfDoc.save();
            const blob = new Blob([savedBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = "OIH_OCR_Synced.pdf";
            link.click();

        } catch (err) {
            console.error(err);
            alert("Save failed. Try refreshing.");
        } finally {
            document.body.classList.remove('exporting');
        }
    }

    function undo() {
        if(!activeElements.length) return;
        const el = activeElements.pop();
        el.remove();
    }
</script>
</body>
</html>
